{"_path":"/interviews/javascript/doc","_dir":"javascript","_draft":false,"_partial":false,"_locale":"","title":"Javascript index","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"javascript"},"children":[{"type":"text","value":"JavaScript"}]},{"type":"element","tag":"h3","props":{"id":"microfrontend"},"children":[{"type":"text","value":"MicroFrontend"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Independent Deployment : Each microfrontend (MFE) is an independent application"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Integration: MEFs can be  composed to create a cohesive user experience"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Technology Agnostic:  Any modern JS Framework can be used"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Routing: Typically managed by shell, host or main application"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Communication: MEFs communicate using events, props, shared state management, web storage, Server session"}]}]},{"type":"element","tag":"h4","props":{"id":"popular-tools"},"children":[{"type":"text","value":"Popular Tools"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Webpack modular federation"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Single SPA"}]}]},{"type":"element","tag":"h4","props":{"id":"communication"},"children":[{"type":"text","value":"Communication"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Browser events"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Browser storage"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Shared state management"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Server APIs and session"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"URL queries"}]}]},{"type":"element","tag":"h3","props":{"id":"singleton"},"children":[{"type":"text","value":"Singleton"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It is a design pattern that ensures a class or module has only one instance and provides a global of access to that instance. This is useful when you want to maintain a single shared state or configuration\nExample: Redux, Global State"}]},{"type":"element","tag":"h3","props":{"id":"promise-async-await"},"children":[{"type":"text","value":"Promise, Async- Await"}]},{"type":"element","tag":"h5","props":{"id":"promise"},"children":[{"type":"text","value":"Promise"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A promise in Javascript is a way to handle asynchronous operations. It can be in one of three states:\npending, resolved or rejected"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"\nconst myPromise = new Promise((resolve, reject) => {\n    const success = true;\n    if(success){\n        resolve('Success')\n    }else{\n        reject('Error')\n    }\n})\n\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nconst myPromise = new Promise((resolve, reject) => {\n    const success = true;\n    if(success){\n        resolve('Success')\n    }else{\n        reject('Error')\n    }\n})\n\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Chaining "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".then()"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".then()"}]},{"type":"text","value":", used to chain promises"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Promise.all()"}]},{"type":"text","value":":  Handling multiple promises with "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Promise.all()"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Promise.allSettled()"}]},{"type":"text","value":": Resolved when all promises settled(fulfilled or rejected)\n"},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"  const responseAll = await Promise.allSettled([new Promise(), new Promise(), new Promise()]);\n  responseAll.forEach((result, reject) => {\n    if(result.status === 'fulfilled'){\n      // Success \n    } else {\n      // Error \n    }\n  })\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  const responseAll = await Promise.allSettled([new Promise(), new Promise(), new Promise()]);\n  responseAll.forEach((result, reject) => {\n    if(result.status === 'fulfilled'){\n      // Success \n    } else {\n      // Error \n    }\n  })\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Promise.race()"}]},{"type":"text","value":": Resolves/Rejects as soon as the first promise settles"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Promise.any()"}]},{"type":"text","value":": Resolves as soon as the first promise resolves; reject if all promise reject"}]}]},{"type":"element","tag":"h5","props":{"id":"prototype"},"children":[{"type":"text","value":"Prototype"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In Javascript, a prototype is an object that acts as a blueprint for other projects. Every Javascript object has a prototype\nfrom which it can inherit properties and methods. This mechanism is part of Javascript's prototype inheritance, which\nallows objects to share properties and methods without duplication"}]},{"type":"element","tag":"h5","props":{"id":"closure"},"children":[{"type":"text","value":"Closure"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A closure in JavaScript is a feature that allows a function to \"remember\" the variables from its surrounding scope, even after the outer function has finished executing. Closures are created every time a function is defined inside another function, and the inner function accesses variables from the outer function's scope."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Key Concepts"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Function within a function: A closure is created when a function is defined inside another function."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Access to outer variables: The inner function can access variables declared in the outer function, even after the outer function has returned."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Encapsulation: Closures allow you to create private variables that cannot be accessed from outside the enclosing function."}]}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"function outerFunction() {\n  let outerVariable = \"I'm from outer function!\";\n\n  function innerFunction() {\n    console.log(outerVariable); // Accesses the outer function's variable\n  }\n\n  return innerFunction;\n}\n\nconst myClosure = outerFunction(); // Returns the inner function\nmyClosure(); // Logs: \"I'm from outer function!\"\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"function outerFunction() {\n  let outerVariable = \"I'm from outer function!\";\n\n  function innerFunction() {\n    console.log(outerVariable); // Accesses the outer function's variable\n  }\n\n  return innerFunction;\n}\n\nconst myClosure = outerFunction(); // Returns the inner function\nmyClosure(); // Logs: \"I'm from outer function!\"\n"}]}]},{"type":"element","tag":"h5","props":{"id":"currying"},"children":[{"type":"text","value":"Currying"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Currying in JavaScript is a functional programming technique where a function is transformed into a series of functions, each taking a single argument. Instead of taking all arguments at once, the function takes one argument, then returns another function that takes the next argument, and so on, until all arguments have been provided."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Reusability: You can create specialized functions by providing some of the arguments upfront."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Readability: Currying can make code more declarative and expressive."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Avoiding repetition: Useful for scenarios where a function is frequently called with the same initial arguments."}]}]},{"type":"element","tag":"h5","props":{"id":"handle-memory-leak-in-javascript"},"children":[{"type":"text","value":"Handle Memory Leak in JavaScript"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A memory leak in JavaScript occurs when memory that is no longer needed is not released, preventing the garbage collector from reclaiming it. This leads to increased memory usage over time, which can cause performance degradation or even application crashes."}]},{"type":"element","tag":"h6","props":{"id":"global-variables"},"children":[{"type":"text","value":"Global Variables"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unintentionally declared variables are added to the global scope and persist for the lifetime of the application."}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"\nfunction someEvents(){\n    isItAGlobalVariable = 'Some thing '; // no var, let, const, it will act as global variable \n}\n\nsomeEvents()\n\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nfunction someEvents(){\n    isItAGlobalVariable = 'Some thing '; // no var, let, const, it will act as global variable \n}\n\nsomeEvents()\n\n"}]}]},{"type":"element","tag":"h6","props":{"id":"clear-timers-or-intervals"},"children":[{"type":"text","value":"Clear Timers or Intervals"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unused "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setInterval"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setTimeout"}]},{"type":"text","value":" references keep running even after they are no longer needed."}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"let intervalId = setInterval(() => console.log('Still running'), 1000);\nclearInterval(intervalId)\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let intervalId = setInterval(() => console.log('Still running'), 1000);\nclearInterval(intervalId)\n"}]}]},{"type":"element","tag":"h6","props":{"id":"detached-dom-events"},"children":[{"type":"text","value":"Detached DOM Events"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Retaining references to DOM elements that are removed from the document"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"let node = document.createElement('div');\ndocument.body.appendChild(node);\ndocument.body.removeChild(node);\nnode = null; \n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let node = document.createElement('div');\ndocument.body.appendChild(node);\ndocument.body.removeChild(node);\nnode = null; \n"}]}]},{"type":"element","tag":"h6","props":{"id":"event-listener"},"children":[{"type":"text","value":"Event listener"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Event listeners attached to elements can prevent garbage collection if not removed"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"  const button = document.getElementById(\"myButton\");\n  function handleClick() {\n      console.log(\"Clicked!\");\n  }\n  button.addEventListener(\"click\", handleClick);\n  button.removeEventListener(\"click\", handleClick); // Clean up when done\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  const button = document.getElementById(\"myButton\");\n  function handleClick() {\n      console.log(\"Clicked!\");\n  }\n  button.addEventListener(\"click\", handleClick);\n  button.removeEventListener(\"click\", handleClick); // Clean up when done\n"}]}]},{"type":"element","tag":"h6","props":{"id":"use-weakmap-and-weakset-for-object-reference"},"children":[{"type":"text","value":"Use "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"WeakMap"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"WeakSet"}]},{"type":"text","value":" for object reference"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unlike Map or Set, these structures do not prevent garbage collection of keys."}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"  const weakMap = new WeakMap();\n  let obj = {};\n  weakMap.set(obj, \"value\");\n  obj = null; // Now the object can be garbage collected\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  const weakMap = new WeakMap();\n  let obj = {};\n  weakMap.set(obj, \"value\");\n  obj = null; // Now the object can be garbage collected\n"}]}]},{"type":"element","tag":"h6","props":{"id":"use-a-garbage-collection-controller"},"children":[{"type":"text","value":"Use a Garbage Collection Controller"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Trigger garbage collection manually (only for debugging purposes) using"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"  if (window.gc) {\n      gc(); // Requires the browser to be started with special flags\n  }\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  if (window.gc) {\n      gc(); // Requires the browser to be started with special flags\n  }\n"}]}]},{"type":"element","tag":"h6","props":{"id":"best-practices"},"children":[{"type":"text","value":"Best Practices"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Minimize Long-Lived References: Avoid keeping objects alive longer than necessary."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Use Weak References: Replace Map or Set with WeakMap or WeakSet for objects."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Monitor Application Performance: Regularly check memory usage in development."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Test for Memory Leaks: Use tools like Chrome DevTools or libraries like leak-canary for testing."}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"microfrontend","depth":3,"text":"MicroFrontend"},{"id":"singleton","depth":3,"text":"Singleton"},{"id":"promise-async-await","depth":3,"text":"Promise, Async- Await"}]}},"_type":"markdown","_id":"content:interviews:javascript:doc:index.md","_source":"content","_file":"interviews/javascript/doc/index.md","_stem":"interviews/javascript/doc/index","_extension":"md"}