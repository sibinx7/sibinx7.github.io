{"_path":"/interviews/nodejs/doc","_dir":"nodejs","_draft":false,"_partial":false,"_locale":"","title":"Node JS Basic","description":"","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"what-is-event-loop"},"children":[{"type":"text","value":"What is Event Loop"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The Event loop is what allows Node.js to perform non-blocking I/O operations – despite the fact that a single JavaScript thread is used by default – by offloading operations to the system kernel whenever possible."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Since modern kernels are multi-threaded, they can handle multiple operations executing in the background. When one of these operations completes, the kernel tells Node.js so that the appropriate callback may be added to the poll queue to eventually be executed. We’ll explain this in further detail later in this topic."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Evenet Loop","src":"/images/interviews/nodejs/node-event-loop.png"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"timer-phase"},"children":[{"type":"text","value":"Timer Phase"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Execute callbacks schedules by "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setTimeout"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setInterval"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"If a time's delay has elapsed, its callback is added to the queue and executed in this phase"}]}]},{"type":"element","tag":"h4","props":{"id":"io-callbacks-phase"},"children":[{"type":"text","value":"I/O Callbacks Phase"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Executes almost all callbacks from asynchronous I/O operations like "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fs"}]},{"type":"text","value":" or "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"net"}]}]}]},{"type":"element","tag":"h4","props":{"id":"idle-prepare-phase"},"children":[{"type":"text","value":"Idle, Prepare Phase"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Used internally by Node.js to prepare next phases"}]}]},{"type":"element","tag":"h4","props":{"id":"pol-phase"},"children":[{"type":"text","value":"Pol Phase"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Retrieve new I/O events and executes their callbacks (if any exist)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"it also waits for I/O operations to complete if none are pending"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"If no timers are scheduled and no I/O waiting, the event loop can pause in this phase"}]}]},{"type":"element","tag":"h4","props":{"id":"check-phase"},"children":[{"type":"text","value":"Check Phase"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Execute callback from "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setTimeout"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Callbacks schedules with "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setIntermediate"}]},{"type":"text","value":" are executed after the poll phase, regardless of I/O status"}]}]},{"type":"element","tag":"h4","props":{"id":"close-callback-phase"},"children":[{"type":"text","value":"Close Callback Phase"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Handle close events such as when a "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"net"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Socket"}]},{"type":"text","value":" connection close"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"If a socket or handle  closed abruptly the close event will be emitted in this phase. Otherwise it will emitted via "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"process.nextTick()"}]}]}]},{"type":"element","tag":"h4","props":{"id":"processnexttick"},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"process.nextTick"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"process.nextTick()"}]},{"type":"text","value":" is a special function in node.js used to schedule a callback function to execute immediately after the current operation completes, before the event loop continues to the next phase.it allows developers to prioritize certain operations over other asynchronous tasks."}]},{"type":"element","tag":"li","props":{},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"what-is-event-loop","depth":2,"text":"What is Event Loop"}]}},"_type":"markdown","_id":"content:interviews:nodejs:doc:index.md","_source":"content","_file":"interviews/nodejs/doc/index.md","_stem":"interviews/nodejs/doc/index","_extension":"md"}